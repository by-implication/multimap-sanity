#+TITLE: Multiple Service Sanity with ClojureScript
#+SUBTITLE: Part 1 - An Introduction to Protocols

* Introduction

In early 2018, google announced a change in the pricing of their maps services,
finally implementing it half a year later. The new prices would have been
prohibitively expensive for many tech companies (think thousands of U.S. dollars a
month) and many scrambled to find alternatives. Along with everyone else who was
affected, we had to:

1. Find alternative service providers for each google maps service we used
2. Compare pricing, quality, and licensing (Many providers, while good, forbade
   the combination of their service with others. Even more maddening, few
   actually support the Philippines.)
3. Decide, and then implement across all affected platforms.

The problem is, of course, that step 3 is a lot of engineering effort, and steps
1 and 2 take time. When customer satisfaction and operation costs are on the
line, one does not simply say:

#+BEGIN_QUOTE
"Nah, fam. I already implemented the thing. We're stuck with this suboptimal
service because it would take too much effort to switch."
#+END_QUOTE

We can't wait 5 months for a final decision either.

The solution then, is to start early and build out infrastructure to reasonably
support every alternative.

#+CAPTION: Sometimes, overengineering IS the answer.
https://i.imgflip.com/2peutr.jpg

We use two major features: the map and the geocoding service. We'll be focusing
on the map because it's "read only". Information only flows from the app state
into the map, and not the other way around. As for forward and reverse
geocoding, that's for the next post in the series.

* The Smart Way

Modern mapping libraries have roughly the same features. Beyond displaying the
map itself, one can expect to place markers or pins, draw lines and shapes, and
control what part of the map is shown. While these features are relatively
consistent, their APIs vary greatly across alternatives.

Javascript's prototypes and classes may help bring sanity to this, but Clojure
(and therefore ClojureScript) offers a slightly different approach with
protocols: instead of dealing with a hierarchy, you deal with characteristics. I
won't further compare prototypes and protocols, as this is out of the scope of
this article.

The great thing is, you can extend existing javascript types with your protocols

Another great thing, protocols can be composed.

The first step is in declaring the protocols (usually in a separate namespace,
but not really necessary.) Please read the inline documentation--they're part of
this article!

#+BEGIN_SRC clojure
(ns sanity.protocols)

(defprotocol MapLike
  "Things-that-are-like-maps."
  (get-dom-node [this]
    "Returns the dom-node that this map is attached to.")
  (add-marker! [this marker-config]
    "For now, marker-config only has one relevant key: `:position`")
  (add-polyline! [this polyline-config]
    "polyline-config has three relevant keys: `:path`, `:stroke-color`, `:stroke-weight`"))

(defprotocol MapEntity
  "For anything that will appear on a map."
  (destroy! [this]
    "Everything can be destroyed!")
  (set-opacity! [this opacity]
    "Most map providers allow you to control the opacity of map entities.
This method can be moved to more specific protocols, but it can stay here."))

(defprotocol MapMarker
  "Specifically map markers."
  (set-position! [this position]
    "It makes sense for this to be a specifically marker thing, since it's a point.
 This doesn't really make sense for shapes and lines."))
#+END_SRC

And now we can implement these protocols as appropriate. Note that in the
following section, I will be using ~extend-type~, which modifies an existing
type (like ~google.maps.Marker~) with additional methods that conform to the
attached protocols. ~extend-type~ is not the only way to use protocols: there's
~defrecord~ and ~reify~, and while they're safer to use than ~extend-type~,
~extend-type~ makes a lot of things more convenient for us. Instead of having to
store the native javascript object as a field in a ClojureScript data structure,
we can just use the object itself.

#+BEGIN_SRC clojure
(ns sanity.google
  (:require [sanity.protocols :as sp]))

(extend-type js/google.maps.Marker
  sp/MapEntity
  (destroy! [this]
    (.setMap this nil)
    nil)
  (set-opacity! [this opacity]
    (.setOpacity this opacity)
    this)

  sp/MapMarker
  (set-position! [this position]
    (.setPosition this position)
    this))

(extend-type js/google.maps.Polyline
  sp/MapEntity
  (destroy! [this]
    (.setMap this nil)
    nil)
  (set-opacity! [this opacity]
    (.setOptions this #js {:strokeOpacity opacity})
    this))

(extend-type js/google.maps.Map
  sp/MapLike
  (get-dom-node [this]
    (.getDiv this))
  (add-marker! [this marker-config]
    (js/google.maps.Marker. (clj->js (assoc marker-config
                                            :map this))))
  (add-polyline! [this polyline-config]
    (js/google.maps.Polyline. (clj->js (assoc polyline-config
                                              :map this)))))

(defn new-google-map [map-config]
  (let [{:keys [dom-node center zoom]} map-config]
    (js/google.maps.Map. dom-node
                         #js {:center (clj->js center)
                              :zoom zoom})))
#+END_SRC

And again in the mapbox namespace.

#+BEGIN_SRC clojure
(ns sanity.mapbox
  (:require [sanity.protocols :as sp]
            ["mapbox-gl" :as mapbox]))


(extend-type mapbox/Marker
  sp/MapEntity
  (destroy! [this]
    (.remove this)
    nil)
  (set-opacity! [this opacity]
    ;; Mapbox markers are interesting. They're actually dom elements
    ;; that are positioned relative to the map. So, to set the marker's
    ;; opacity, we can just apply css styling. I'll leave the implementation
    ;; of this method as an exercise for the reader.
    this)

  sp/MapMarker
  (set-position! [this {:keys [lat lng]}]
    ;; Unfortunately, mapbox and google maps do not agree
    ;; on the representation of map positions.
    (.setLngLat this #js {:lon lng :lat lat})
    this))

;; Mapbox doesn't have polylines as a first-class entity.
;; So we make a record that implements the appropriate protocols.
;; You can think of records as clojure maps that have methods
;; associated with them.
(defrecord MapboxPolyline [street-map id]
  sp/MapEntity
  (destroy! [this]
    (when (.getLayer street-map id)
      (.removeLayer street-map id))
    (when (.getSource street-map id)
      (.removeSource street-map id)))
  (set-opacity! [this opacity]
    (.setPaintProperty street-map id "line-opacity" opacity)))

(extend-type mapbox/Map
  sp/MapLike
  (get-dom-node [this]
    (.getContainer this))
  (add-marker! [this {:keys [position] :as marker-config}]
    (-> (mapbox/Marker. #js {})
        (sp/set-position! position)
        (.addTo this)))
  (add-polyline! [this {path :path
                        stroke-color :strokeColor
                        stroke-weight :strokeWeight
                        :as polyline-config}]
    ;; This bit is long because mapbox treats polylines differently from google maps.
    ;; Remember what I said about vastly different APIs? :P
    (let [polyline-id (random-uuid)
          line-source {:type "geojson"
                       :data {:type     "Feature"
                              :geometry {:type        "LineString"
                                         :properties  {}
                                         :coordinates (map (fn [{:keys [lat lng]}]
                                                             [lng lat])
                                                           path)}}}
          line-layer (clj->js
                      {:id     polyline-id
                       :type   "line"
                       :layout {:line-join "round"
                                :line-cap  "round"}
                       :paint  {:line-color stroke-color
                                :line-width stroke-weight}
                       :source line-source})]
      (.addLayer this line-layer)
      (map->MapboxPolyline {:street-map this
                            :id         polyline-id}))))

(defn new-mapbox-map [{:keys [dom-node center zoom style]}]
  (let [{:keys [lat lng]} center]
    (mapbox/Map. #js {:container dom-node
                      :center    #js [lng lat]
                      :zoom      zoom
                      :style     "https://tiles.stadiamaps.com/styles/alidade_smooth.json"})))
#+END_SRC

Now that our implementations are complete, we can use them.

#+BEGIN_SRC clojure
(ns sanity.core
  (:require [sanity.protocols :as sp]
            [sanity.google]
            [sanity.mapbox]))

(def use-google (atom false))
(def app-map (atom nil))

(defn init-map []
  (let [map-config {:dom-node (js/document.getElementById "map")
                    :zoom     12
                    :center   {:lat 14.6091
                               :lng 121.0223}}]
    (if @use-google
      (sanity.google/new-google-map map-config)
      (sanity.mapbox/new-mapbox-map map-config))))

(defn setup []
  (reset! app-map (init-map))
  ;; Notice that it doesn't care if the map is google or mapbox.
  ;; The correct implementation will be used regardless.
  (sp/add-marker! @app-map {:position {:lat 14.6091
                                       :lng 121.0223}}))

(defn ^:export switch-provider []
  (swap! use-google not)
  (setup))

(defn ^:export init []
  (let [switch-button (js/document.getElementById "switch-button")]
    (.addEventListener switch-button "click" switch-provider))
  (setup))
#+END_SRC


* Classes and Protocols

Consider pigeons, penguins, submarines, and airplanes.

In typical class-based systems, you would model them as
- Pigeons and penguins are Birds
- Submarines and airplanes are Vehicles
But pigeons and submarines both dive, and pigeons and airplanes fly. Since
penguins and submarines are from different classes, their dive methods

With protocols
- Pigeons implement Birdlike, Flier
- Penguins implement Birdlike, Diver
- Submarines implement Vehicle, Diver
- Airplanes implement Vehicle, Flier

With classes, birds and airplanes couldn't easily share polymorphism for flying.
They could look like they share the same interface for flying, but they belong
to different hierarchies, and so can change independently of each other. With
protocols, they literally share the same Flyer protocol, so any change in API
would result in both birds and airplanes updating.
